include "buzz_includes/buzz_utils/vec2.bzz"
include "buzz_includes/buzz_utils/string.bzz"
include "config/search_example/parameters.bzz"
include "buzz_includes/search_example/global_variables.bzz"
include "buzz_includes/debug.bzz"

# Executed at init time
function init() {
  # Take off command for the Spiri drone model
  takeoff()

  # Show trajectory for debugging
  show_colored_trajectory(NUMBER_OF_ROBOTS)

  # Set first search position
  next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
  next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)
  goto(next_position.x, next_position.y)

  # Set initial state
  current_state = STATE_SEARCH
}

# Check if a target is in sight
function has_discovered_target()
{ 
  return detect_targets()
}

# Continue random search
function random_search_next_position()
{ 
  next_position.x = uniform(next_position.x-SEARCH_SPEED, next_position.x+SEARCH_SPEED)
  next_position.y = uniform(next_position.y-SEARCH_SPEED, next_position.y+SEARCH_SPEED)
  goto(next_position.x, next_position.y)
}

# Listen to others
function listen_for_found_targets(){
    neighbors.listen("found_target_info",
                  function(vid, value, rid)  {
                      if (value.found == 1) { 
                        found_target_info.another_robot_found = rid
                        found_target_info.x = value.x
                        found_target_info.y = value.y
                      }
                    }
                    )
}

# Executed every time step
function step() {

  # Update sensors and communication data
  listen_for_found_targets()
  update_gps_position()

  ### State machine ###
  
  ## Searching for the target
  if (current_state == STATE_SEARCH){ 
    debug.print("Searching")
    # Look if a target is discovered
    if ( has_discovered_target() != 0 ) { 
      found_target_info.found = 1
      found_target_info.x = gps_position.x
      found_target_info.y = gps_position.y
      neighbors.broadcast("found_target_info", found_target_info)
      goto(MEETING_POINT.x, MEETING_POINT.y)
      current_state = STATE_FOUND
      current_search_step = 0      
    } 
    # If the max number of search step is reached go back to meeting point
    else if ( current_search_step >= NUMBER_OF_SEARCH_STEP ){ 
      goto(MEETING_POINT.x, MEETING_POINT.y)
      current_state = STATE_MEETING
      current_search_step = 0
    }
    # Else continue searching
    else { 
      if ( has_reached(next_position.x, next_position.y, DELTA_REACHED_POS) != 0 )
      {
        random_search_next_position()
        current_search_step = current_search_step + 1
      }
    }

  }
  # The robot that found the target stays at the meeting point and broacast its info
  else if ( current_state == STATE_FOUND ){ 
    debug.print("Found the target")
    neighbors.broadcast("found_target_info", found_target_info)
  }
  # At some point the other robots go the meeting point and see if another robot found something
  else if ( current_state == STATE_MEETING ){ 
    debug.print("Periodic meeting")
    if ( has_reached(MEETING_POINT.x, MEETING_POINT.y, DELTA_REACHED_POS) == 0 ) {
      # Look for targets when comming back to meeting point
      if ( has_discovered_target() != 0 ) { 
        found_target_info.found = 1
        found_target_info.x = gps_position.x
        found_target_info.y = gps_position.y
        neighbors.broadcast("found_target_info", found_target_info)
        goto(MEETING_POINT.x, MEETING_POINT.y)
        current_state = STATE_FOUND
        current_search_step = 0      
      } 
    }
    # If another robot found a target, go in relay position
    else if (found_target_info.another_robot_found != -1)
    {
      relay_id = id
      if (relay_id < found_target_info.another_robot_found){
        relay_id = relay_id + 1
      }
      relay_ratio = float(relay_id) / float(NUMBER_OF_ROBOTS-1)
      relay_x = (found_target_info.x - MEETING_POINT.x ) * relay_ratio + MEETING_POINT.x
      relay_y = (found_target_info.y - MEETING_POINT.y ) * relay_ratio + MEETING_POINT.y
      goto(relay_x, relay_y)
      current_state = STATE_RELAY
      debug.print("Communication relay")
    }
    # Else continue searching
    else
    {
      next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
      next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)
      goto(next_position.x, next_position.y)
      current_state = STATE_SEARCH
    }
  }

}
 
# Execute at exit
function destroy() {
}
